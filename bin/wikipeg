#!/usr/bin/env node

"use strict";

var util = require("util");
var fs   = require("fs");
var path = require("path");
var PEG  = require("../lib/peg");

/* Helpers */

function printVersion() {
  util.puts("WikiPEG " + PEG.VERSION);
}

function printHelp() {
  util.puts(`Usage: wikipeg [options] [--] [<input_file>] [<output_file>]

Generates a parser from the PEG grammar specified in the <input_file> and writes
it to the <output_file>.

If <input_file> has the extension .pegjs, JavaScript output is selected and the
default <output_file> will be generated by replacing ".pegjs" with ".js".

If <input_file> has the extension .pegphp, PHP output is selected and the
default <output_file> will be generated by replacing ".pegphp" with ".php".

If both <input_file> and <output_file> are omitted, standard input and output
are used.

Options:
  -e, --export-var <variable>        name of the variable where the parser
                                     object will be stored (default:
                                     "module.exports")
      --php                          force PHP mode regardless of extension
      --class-name <name>            specify generated PHP class name
      --cache                        make generated parser cache results
      --allowed-start-rules <rules>  comma-separated list of rules the generated
                                     parser will be allowed to start parsing
                                     from (default: the first rule in the
                                     grammar)
      --trace                        enable tracing in generated parser
      --allow-loops                  disable the infinite loop check
      --plugin <plugin>              use a specified plugin (can be specified
                                     multiple times)
      --extra-options <options>      additional options (in JSON format) to pass
                                     to PEG.buildParser
      --extra-options-file <file>    file with additional options (in JSON
                                     format) to pass to PEG.buildParser
  -v, --version                      print version information and exit
  -h, --help                         print help and exit
`);
}

function exitSuccess() {
  process.exit(0);
}

function exitFailure() {
  process.exit(1);
}

function abort(message) {
  util.error(message);
  exitFailure();
}

function addExtraOptions(options, json) {
  var extraOptions;

  try {
    extraOptions = JSON.parse(json);
  } catch (e) {
    if (!(e instanceof SyntaxError)) { throw e; }

    abort("Error parsing JSON: " + e.message);
  }
  if (typeof extraOptions !== "object") {
    abort("The JSON with extra options has to represent an object.");
  }

  for (var key in extraOptions) {
    if (extraOptions.hasOwnProperty(key)) {
      options[key] = extraOptions[key];
    }
  }
}

/*
 * Extracted into a function just to silence JSHint complaining about creating
 * functions in a loop.
 */
function trim(s) {
  return s.trim();
}

/* Arguments */

var args = process.argv.slice(2); // Trim "node" and the script path.

function isOption(arg) {
  return (/^-/).test(arg);
}

function nextArg() {
  args.shift();
}

/* Files */

function readStream(inputStream, callback) {
  var input = "";
  inputStream.on("data", function(data) { input += data; });
  inputStream.on("end", function() { callback(input); });
}

/* Main */

/* This makes the generated parser a CommonJS module by default. */
var exportVar = "module.exports";
var options = {
  cache:    false,
  output:   "source",
  trace:    false,
  plugins:  [],
  language: null,
  commonLang: null,
};

while (args.length > 0 && isOption(args[0])) {
  switch (args[0]) {
    case "-e":
    case "--export-var":
      exportVar = args[0];
      break;

    case "--php":
      options.language = "php";
      break;

    case '--common-lang':
      options.commonLang = true;
      break;

    case '--class-name':
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the --class-name option.");
      }
      options.className = args[0];
      break;

    case "--cache":
      options.cache = true;
      break;

    case '--allow-loops':
      options.allowLoops = true;
      break;

    case "--allowed-start-rules":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the -e/--allowed-start-rules option.");
      }
      options.allowedStartRules = args[0]
        .split(",")
        .map(trim);
      break;

    case "--trace":
      options.trace = true;
      break;

    case "--plugin":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the --plugin option.");
      }
      var id = /^(\.\/|\.\.\/)/.test(args[0]) ? path.resolve(args[0]) : args[0];
      var mod;
      try {
        mod = require(id);
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND") { throw e; }

        abort("Can't load module \"" + id + "\".");
      }
      options.plugins.push(mod);
      break;

    case "--extra-options":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the --extra-options option.");
      }
      addExtraOptions(options, args[0]);
      break;

    case "--extra-options-file":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the --extra-options-file option.");
      }
      try {
        var json = fs.readFileSync(args[0]);
      } catch(e) {
        abort("Can't read from file \"" + args[0] + "\".");
      }
      addExtraOptions(options, json);
      break;

    case "-v":
    case "--version":
      printVersion();
      exitSuccess();
      break;

    case "-h":
    case "--help":
      printHelp();
      exitSuccess();
      break;

    case "--":
      nextArg();
      break;

    default:
      abort("Unknown option: " + args[0] + ".");
  }
  nextArg();
}

var inputStream, outputStream;

switch (args.length) {
  case 0:
    process.stdin.resume();
    inputStream = process.stdin;
    outputStream = process.stdout;
    break;

  case 1:
  case 2:
    var inputFile = args[0];
    inputStream = fs.createReadStream(inputFile);
    inputStream.on("error", function() {
      abort("Can't read from file \"" + inputFile + "\".");
    });

    if (options.language === null) {
      if (/\.pegphp$/.test(inputFile)) {
        options.language = 'php';
      } else {
        options.language = 'javascript';
      }
    }

    if (/\.peg$/.test(inputFile) && options.commonLang === null) {
      options.commonLang = true;
    }

    var extension = options.language === 'php' ? ".php" : ".js";

    var outputFile = args.length === 1
      ? args[0].replace(/\.[^.]*$/, extension)
      : args[1];
    outputStream = fs.createWriteStream(outputFile);
    outputStream.on("error", function() {
      abort("Can't write to file \"" + outputFile + "\".");
    });

    break;

  default:
    abort("Too many arguments.");
}

if (options.language === undefined) {
  options.language = 'javascript';
}

readStream(inputStream, function(input) {
  var source;

  try {
    source = PEG.buildParser(input, options);
  } catch (e) {
    if (e.location !== undefined) {
      abort(e.location.start.line + ":" + e.location.start.column + ": " + e.message);
    } else {
      throw e;
    }
  }

  if (options.language === 'javascript') {
    outputStream.write(exportVar !== "" ? `${exportVar} = ${source}\n` : `${source}\n`);
  } else {
    outputStream.write(source + "\n");
  }
  if (outputStream !== process.stdout) {
    outputStream.end();
  }
});
